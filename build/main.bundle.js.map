{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;;AAAa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,mCAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,aAAa;AACb,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB,aAAa;AACb,yBAAyB,2BAA2B;AACpD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5Wa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,gBAAgB,GAAG,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,aAAa;AACb;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,aAAa;AACb;AACA,kBAAkB;;;;;;;UC9ElB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://webgputs/./src/main.ts","webpack://webgputs/./src/shaders.ts","webpack://webgputs/webpack/bootstrap","webpack://webgputs/webpack/before-startup","webpack://webgputs/webpack/startup","webpack://webgputs/webpack/after-startup"],"sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst shaders_1 = require(\"./shaders\");\r\nconst colorValues = [\r\n    [128, 0, 0],\r\n    [128, 128, 0],\r\n    [0, 128, 0],\r\n    [128, 0, 128],\r\n    [0, 128, 128],\r\n    [0, 0, 128]\r\n];\r\nfunction CheckWebGPU() {\r\n    let result = \"Great, your current browser supports WebGPU!\";\r\n    if (!navigator.gpu) {\r\n        result = \"Your current browser does not support WebGPU\";\r\n    }\r\n    return result;\r\n}\r\nlet test = document.getElementById(\"id-gpu-check\");\r\nif (test != null) {\r\n    test.innerHTML = CheckWebGPU();\r\n}\r\nfunction initGPU(canvasName) {\r\n    var _a;\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const canvas = document.getElementById(canvasName);\r\n        const adapter = yield ((_a = navigator.gpu) === null || _a === void 0 ? void 0 : _a.requestAdapter());\r\n        const device = yield (adapter === null || adapter === void 0 ? void 0 : adapter.requestDevice());\r\n        const context = canvas.getContext(\"webgpu\");\r\n        const swapChainFormat = \"bgra8unorm\";\r\n        context.configure({\r\n            device: device,\r\n            format: swapChainFormat,\r\n        });\r\n        return { device, context, swapChainFormat };\r\n    });\r\n}\r\nfunction createBuffer(device, data, usageFlag = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) {\r\n    const buffer = device.createBuffer({\r\n        size: data.byteLength,\r\n        usage: usageFlag,\r\n        mappedAtCreation: true\r\n    });\r\n    new Float32Array(buffer.getMappedRange()).set(data);\r\n    buffer.unmap();\r\n    return buffer;\r\n}\r\nfunction createIntBuffer(device, data, usageFlag = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) {\r\n    const buffer = device.createBuffer({\r\n        size: data.byteLength,\r\n        usage: usageFlag,\r\n        mappedAtCreation: true\r\n    });\r\n    new Int32Array(buffer.getMappedRange()).set(data);\r\n    buffer.unmap();\r\n    return buffer;\r\n}\r\nfunction CreateTriangle(color = \"(1.0,1.0,1.0,1.0)\") {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        console.log(\"Creating Triangle\");\r\n        if (!navigator.gpu) {\r\n            throw (\"Your current browser does not support WebGPU!\");\r\n        }\r\n        const gpu = yield initGPU(\"canvas-webgpu\");\r\n        const device = gpu.device;\r\n        const context = gpu.context;\r\n        const swapChainFormat = gpu.swapChainFormat;\r\n        const shader = (0, shaders_1.Shaders)(color);\r\n        const pipeline = device.createRenderPipeline({\r\n            vertex: {\r\n                module: device.createShaderModule({\r\n                    code: shader.vertex\r\n                }),\r\n                entryPoint: \"main\"\r\n            },\r\n            multisample: {\r\n                count: 4,\r\n                alphaToCoverageEnabled: false\r\n            },\r\n            fragment: {\r\n                module: device.createShaderModule({\r\n                    code: shader.fragment\r\n                }),\r\n                entryPoint: \"main\",\r\n                targets: [{\r\n                        format: swapChainFormat\r\n                    }]\r\n            },\r\n            primitive: { topology: \"triangle-list\" },\r\n            depthStencil: {\r\n                format: swapChainFormat\r\n            }\r\n        });\r\n        const commandEncoder = device.createCommandEncoder();\r\n        const myTexture = device.createTexture({\r\n            size: {\r\n                width: 640,\r\n                height: 640\r\n            },\r\n            sampleCount: 4,\r\n            format: swapChainFormat,\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\r\n        });\r\n        const attachment = myTexture.createView();\r\n        const textureView = context.getCurrentTexture().createView();\r\n        const renderPass = commandEncoder.beginRenderPass({\r\n            colorAttachments: [{\r\n                    view: attachment,\r\n                    resolveTarget: textureView,\r\n                    loadValue: [0.5, 0.5, 0.8, 1],\r\n                    storeOp: \"discard\"\r\n                }]\r\n        });\r\n        renderPass.setPipeline(pipeline);\r\n        renderPass.draw(3, 1, 0, 0);\r\n        renderPass.endPass();\r\n        device.queue.submit([commandEncoder.finish()]);\r\n    });\r\n}\r\nfunction toRadians(angle) {\r\n    return angle * (Math.PI / 180);\r\n}\r\nfunction rotate(angle, point) {\r\n    let resultX = (point[0] * Math.cos(toRadians(angle))) + (point[1] * Math.sin(toRadians(angle)));\r\n    let resultY = (-1 * point[0] * Math.sin(toRadians(angle))) + (point[1] * Math.cos(toRadians(angle)));\r\n    return [resultX, resultY];\r\n}\r\nfunction rotateMatrix(angle, matrix) {\r\n    let vertexs = [];\r\n    for (var i = 0; i < matrix.length; i++) {\r\n        vertexs.push(rotate(angle, matrix[i]));\r\n    }\r\n    return vertexs;\r\n}\r\nfunction offsetMatrix(matrix) {\r\n    for (var i = 0; i < matrix.length; i++) {\r\n        matrix[i] = matrix[i] + .5;\r\n    }\r\n}\r\nfunction matToArray(matrix) {\r\n    let arr = [];\r\n    for (var i = 0; i < matrix.length; i++) {\r\n        arr.push(matrix[i][0]);\r\n        arr.push(matrix[i][1]);\r\n    }\r\n    return arr;\r\n}\r\nfunction createWedge(start, current, resolution) {\r\n    let vertexs = [];\r\n    // center\r\n    vertexs.push([.0, .0]);\r\n    // top\r\n    vertexs.push([.0, .9]);\r\n    // right\r\n    let right = rotate(current, [.0, .9]);\r\n    vertexs.push(right);\r\n    // build small triangles\r\n    //const halfway = [.0 - (.0 - right[0]) / 2, .9 - (.9 - right[1]) / 2];\r\n    const halfway = [right[0] / 2, .9 - (.9 - right[1]) / 2];\r\n    // rotate by start\r\n    let beginX = .0;\r\n    let beginY = .9;\r\n    let max = current * resolution;\r\n    for (var i = 1; i < max + 1; i++) {\r\n        // first\r\n        vertexs.push([beginX, beginY]);\r\n        // second\r\n        let end = rotate(current / max * i, [0.0, 0.9]);\r\n        vertexs.push(end);\r\n        // center\r\n        vertexs.push(halfway);\r\n        beginX = end[0];\r\n        beginY = end[1];\r\n    }\r\n    vertexs = rotateMatrix(start, vertexs);\r\n    vertexs = matToArray(vertexs);\r\n    //offsetMatrix(vertexs);\r\n    return vertexs;\r\n}\r\nfunction getWedgeColorVertexs(start, size, resolution, colorIndex) {\r\n    let colors = [];\r\n    let vertexs = [];\r\n    let wedge = createWedge(start, size, resolution);\r\n    for (var j = 0; j < wedge.length; j++) {\r\n        if (j % 2 == 0) {\r\n            colors.push(colorValues[colorIndex][0]);\r\n            colors.push(colorValues[colorIndex][1]);\r\n            colors.push(colorValues[colorIndex][2]);\r\n        }\r\n        vertexs.push(wedge[j]);\r\n    }\r\n    return [colors, vertexs];\r\n}\r\nfunction pieChart(categories, resolution) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        console.log(\"Creating Triangle\");\r\n        if (!navigator.gpu) {\r\n            throw (\"Your current browser does not support WebGPU!\");\r\n        }\r\n        const gpu = yield initGPU(\"canvas-pie\");\r\n        const device = gpu.device;\r\n        const context = gpu.context;\r\n        const swapChainFormat = gpu.swapChainFormat;\r\n        categories = categories.sort((a, b) => a - b);\r\n        let currentStart = 0;\r\n        let vertexs = [];\r\n        let colors = [];\r\n        for (var i = 0; i < categories.length; i++) {\r\n            if (categories[i] > 180) {\r\n                const categorySize = categories[i];\r\n                const min = Math.floor(categorySize / 90);\r\n                const remainder = categorySize % 90;\r\n                let wedges;\r\n                if (remainder === 0) {\r\n                    wedges = min;\r\n                }\r\n                else {\r\n                    wedges = min + 1;\r\n                }\r\n                for (let j = 0; j < wedges; j++) {\r\n                    let size = 90;\r\n                    if (j === wedges - 1) {\r\n                        size = remainder;\r\n                    }\r\n                    const colorVerts = getWedgeColorVertexs(currentStart, size, resolution, i);\r\n                    colorVerts[0].map((value) => {\r\n                        colors.push(value);\r\n                    });\r\n                    colorVerts[1].map((value) => {\r\n                        vertexs.push(value);\r\n                    });\r\n                    currentStart += size;\r\n                }\r\n            }\r\n            else {\r\n                const colorVerts = getWedgeColorVertexs(currentStart, categories[i], resolution, i);\r\n                colorVerts[0].map((value) => {\r\n                    colors.push(value);\r\n                });\r\n                colorVerts[1].map((value) => {\r\n                    vertexs.push(value);\r\n                });\r\n            }\r\n            currentStart += categories[i];\r\n        }\r\n        const vertexBuffer = createBuffer(device, Float32Array.from(vertexs));\r\n        const colorBuffer = createBuffer(device, Float32Array.from(colors));\r\n        const shader = (0, shaders_1.Shaders1)();\r\n        const pipeline = device.createRenderPipeline({\r\n            vertex: {\r\n                module: device.createShaderModule({\r\n                    code: shader.vertex\r\n                }),\r\n                buffers: [{\r\n                        arrayStride: 8,\r\n                        attributes: [{\r\n                                format: \"float32x2\",\r\n                                offset: 0,\r\n                                shaderLocation: 0\r\n                            }]\r\n                    }, {\r\n                        arrayStride: 12,\r\n                        attributes: [{\r\n                                format: \"float32x3\",\r\n                                offset: 0,\r\n                                shaderLocation: 1\r\n                            }]\r\n                    }],\r\n                entryPoint: \"main\"\r\n            },\r\n            multisample: {\r\n                count: 4,\r\n                alphaToCoverageEnabled: false\r\n            },\r\n            fragment: {\r\n                module: device.createShaderModule({\r\n                    code: shader.fragment\r\n                }),\r\n                entryPoint: \"main\",\r\n                targets: [{\r\n                        format: swapChainFormat\r\n                    }]\r\n            },\r\n            primitive: { topology: \"triangle-list\" },\r\n        });\r\n        const commandEncoder = device.createCommandEncoder();\r\n        const myTexture = device.createTexture({\r\n            size: {\r\n                width: 640,\r\n                height: 640\r\n            },\r\n            sampleCount: 4,\r\n            format: swapChainFormat,\r\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\r\n        });\r\n        const attachment = myTexture.createView();\r\n        const textureView = context.getCurrentTexture().createView();\r\n        const renderPass = commandEncoder.beginRenderPass({\r\n            colorAttachments: [{\r\n                    view: attachment,\r\n                    resolveTarget: textureView,\r\n                    loadValue: [0.0, 0.5, 1.0, 1],\r\n                    storeOp: \"store\"\r\n                }]\r\n        });\r\n        renderPass.setPipeline(pipeline);\r\n        renderPass.setVertexBuffer(0, vertexBuffer);\r\n        renderPass.setVertexBuffer(1, colorBuffer);\r\n        renderPass.draw(vertexs.length / 2);\r\n        renderPass.endPass();\r\n        device.queue.submit([commandEncoder.finish()]);\r\n    });\r\n}\r\n//document.onload = function() {\r\nlet button = document.getElementById(\"b\");\r\nif (button != null) {\r\n    console.log(\"setting button on click\");\r\n    button.onclick = () => {\r\n        const input = document.getElementById(\"id-color\");\r\n        const color = input.value;\r\n        console.log(`InnerText: ${color}`);\r\n        if (color != null) {\r\n            CreateTriangle(color);\r\n        }\r\n    };\r\n}\r\nelse {\r\n    console.log(\"Fuck the button\");\r\n}\r\nlet pieButton = document.getElementById(\"pie\");\r\nif (pieButton != null) {\r\n    pieButton.onclick = () => {\r\n        const input = document.getElementById(\"id-array\");\r\n        let resolutionInput = document.getElementById(\"id-resolution\");\r\n        const resolution = parseInt(resolutionInput.value);\r\n        const inputArr = input.value.split(\",\");\r\n        let newArr = [];\r\n        let total = 0;\r\n        for (let i = 0; i < inputArr.length; i++) {\r\n            const num = parseInt(inputArr[i]);\r\n            total += num;\r\n            newArr.push(num);\r\n        }\r\n        if (total < 360) {\r\n            newArr.push(360 - total);\r\n        }\r\n        console.log(`InnerText: ${resolution}`);\r\n        if (resolution != null) {\r\n            pieChart(newArr, resolution);\r\n        }\r\n    };\r\n}\r\nelse {\r\n    console.log(\"Fuck the button\");\r\n}\r\n//}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ShadersOld = exports.Shaders1 = exports.Shaders = void 0;\r\nconst Shaders = (color) => {\r\n    const vertex = `\r\n        [[stage(vertex)]]\r\n        fn main([[builtin(vertex_index)]] VertexIndex: u32) -> [[builtin(position)]] vec4<f32> {\r\n            var pos = array<vec2<f32>, 3>(\r\n                vec2<f32>(0.0, 0.5),\r\n                vec2<f32>(-0.5, -0.5),\r\n                vec2<f32>(0.5, -0.5));\r\n            return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\r\n        }\r\n    `;\r\n    const fragment = `\r\n        [[stage(fragment)]]\r\n        fn main() -> [[location(0)]] vec4<f32> {\r\n            return vec4<f32>${color};\r\n        }\r\n    `;\r\n    return { vertex, fragment };\r\n};\r\nexports.Shaders = Shaders;\r\nconst Shaders1 = () => {\r\n    const vertex = `\r\n        struct Inputs {\r\n            [[location(0)]] pos : vec4<f32>;\r\n            [[location(1)]] index: vec4<f32>;\r\n        };\r\n\r\n        struct Outputs {\r\n            [[builtin(position)]] Position : vec4<f32>;\r\n            [[location(0)]] vColor : vec4<f32>;\r\n        };\r\n\r\n        [[stage(vertex)]]\r\n        fn main(in: Inputs) -> Outputs {\r\n            let outPos = vec4<f32>(in.pos[0], in.pos[1], 0.0, 1.0);\r\n            let outColor = vec4<f32>(in.index[0], in.index[1], in.index[2], 1.0);\r\n            var out: Outputs;\r\n            out.Position = outPos;\r\n            out.vColor = outColor;\r\n            return out;\r\n        }\r\n    `;\r\n    const fragment = `\r\n        [[stage(fragment)]]\r\n        fn main([[location(0)]] vColor : vec4<f32>) -> [[location(0)]] vec4<f32> {\r\n            return vColor;\r\n        }\r\n    `;\r\n    return { vertex, fragment };\r\n};\r\nexports.Shaders1 = Shaders1;\r\nconst ShadersOld = (color) => {\r\n    const vertex = `\r\n        const pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\r\n            vec2<f32>(0.0, 0.5),\r\n            vec2<f32>(-0.5, -0.5),\r\n            vec2<f32>(0.5, -0.5));\r\n        [[builtin(position)]] var<out> Position : vec4<f32>;\r\n        [[builtin(vertex_idx)]] var<in> VertexIndex : i32;\r\n        [[stage(vertex)]]\r\n        fn main() -> void {\r\n            Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\r\n            return;\r\n        }\r\n    `;\r\n    const fragment = `\r\n        [[location(0)]] var<out> outColor : vec4<f32>;\r\n        [[stage(fragment)]]\r\n        fn main() -> void {\r\n            outColor = vec4<f32>${color};\r\n            return;\r\n        }\r\n    `;\r\n    return { vertex, fragment };\r\n};\r\nexports.ShadersOld = ShadersOld;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/main.ts\");\n",""],"names":[],"sourceRoot":""}